<<<<<<< HEAD
N <- nrow(df)
df <- df[sample(N), ]
num <- floor(N/size)
size=10 # leave-10-out CV
num <- floor(N/size)
num
rest <- N - num * size
rest
N/size
ncv <- cumsum(c(rep(size,num), rest))
ncv
predictions <- data.frame(survived = df$survived, pred = NA)
size
n = ncv[1]
n
v <- rep(TRUE, N)
v[(n-size+1):n] <- FALSE
v
lr <- glm(survived ~ ., data = df[v,], family = binomial(logit))
lr
predict(lr, newdata = df[!v, ])
predict(lr, newdata = df[!v, ], type = "response")
?predict
log(0.13/0.87)
log(0.136/0.864)
predictions <- data.frame(survived = df$survived, pred = NA)
for(n in ncv) {
v <- rep(TRUE, N)
v[(n-size+1):n] <- FALSE
lr <- glm(survived ~ ., data = df[v,], family = binomial(logit))
predictions[!v,"pred"] <- predict(lr, newdata=df[!v,], type="response")
# type = "resposne" gives predicted probabilities
# default is the linear predictors (log-odds of the probabilities)
=======
lm(V1 ~ V2 + V3 + V4 + V5, data = vif.dt)
summary(lm(V1 ~ V2 + V3 + V4 + V5, data = vif.dt))
vif.lm = summary(lm(V1 ~ V2 + V3 + V4 + V5, data = vif.dt))
1 / ( 1 - vif.lm$r.squared )
vif
vif.dt = as.data.frame(matrix(rnorm(5e2, 0, 1), nrow = 1e2))
vif.dt$V3 = vif.dt$V1 + rnorm(1e2, 0, .5)
cor(vif.dt)
?moveme
x = names(vif.dt)[2]
x
toy.dt = vif.dt[x, setdiff(names(vif.dt), x)]
toy.dt
names(toy.dt) = paste0("V", 1:5)
paste0("V", 1:5)
dim(toy.dt)
toy.dt = vif.dt[vif.dt$x, setdiff(names(vif.dt), x)]
head(toy.dt)
toy.dt = vif.dt[vif.dt[x], setdiff(names(vif.dt), x)]
x
vif.dt[x]
toy.dt = vif.dt[c(x, setdiff(names(vif.dt), x))]
head(toy.dt)
names(toy.dt) = paste0("V", 1:5)
vif = sapply(names(vif.dt), function(x) {
toy.dt = vif.dt[c(x, setdiff(names(vif.dt), x))]
names(toy.dt) = paste0("V", 1:5)
toy.lm = summary(lm(V1 ~ V2 + V3 + V4 + V5, data = toy.dt))
1 / ( 1 - toy.lm$r.squared )
})
vif
vif = diag(ginv(cor(vif.dt)))
vif
vif = diag(MASS::ginv(cor(vif.dt)))
vif
dim(vif.dt)
keep = 5
mat = vif.dt
keep = rep(0,dim(mat)[2])
keep2 = rep(1,dim(mat)[2])
keep
keep2
keep = keep2
keep
this.mat = mat[,which(keep==1)]
head(this.mat)
this.mat = mat[,which(keep==1)]
head(this.mat)
this.vars = which(keep==1)
nvar = length(this.vars)
this.vars
nvar
vif
top_vif = which.max(vif)
top_vif
top_vif_abs = this.vars[top_vif]
top_vif_abs
compute_vif <- function(mat){ #function for computing vif
require(MASS)
vif = diag(ginv(cor(mat)))
return(vif)
>>>>>>> 5eecee47e3d57630a6dbd43636f10954fd772cb9
}
iremove
iremove = 3
vif1 = compute_vif(mat)
vif2 = compute_vif(mat[,-iremove])
vif1
vif2
dvif = log(vif1[-iremove]/vif2)
dvif
vif
vif.top = which.max(vif)
vif.top
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif.top
vif.new
vif = diag(MASS::ginv(cor(vif.dt)))
vif
names(vif) = names(vif.dt)
vif
vif.top = which.max(vif)
vif.top
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif.new
names(vif.new) = names(vif.dt)[-vif.top]
vif.new
vif.drop = vif[-vif.top] - vif.new
vif.drop
allcolumns = 1:dim(mat)[2]
allcolumns
iremove
columns_for_shuffle = allcolumns[-iremove]
columns_for_shuffle
dvif_shuff = c(replicate(nreps, compute_dvif(shuffle_mat(mat,iremove),iremove)))
nshuffle = 100
nreps = ceiling(nshuffle/(ncol(mat) - 1))
nreps
dvif_shuff = c(replicate(nreps, compute_dvif(shuffle_mat(mat,iremove),iremove)))
compute_dvif <- function(mat, iremove){ #function for computing delta VIF after removing variable(s) iremove
vif1 = compute_vif(mat)
vif2 = compute_vif(mat[,-iremove])
dvif = log(vif1[-iremove]/vif2)
return(dvif)
}
dvif_shuff = c(replicate(nreps, compute_dvif(shuffle_mat(mat,iremove),iremove)))
shuffle_mat <- function(mat, iremove){ #shuffle columns of matrix except for variable iremove
allcolumns = 1:dim(mat)[2]
columns_for_shuffle = allcolumns[-iremove]
shuffled_selection = sapply(columns_for_shuffle, function(col) sample(as.numeric(mat[,col])))
shuffled_mat = mat
shuffled_mat[,columns_for_shuffle] = shuffled_selection
return(shuffled_mat)
}
dvif_shuff = c(replicate(nreps, compute_dvif(shuffle_mat(mat,iremove),iremove)))
dvif_shuff
vif.drop
vif.dt[vif.top]
vif.dt[vif.top] = sample(vif.dt[vif.top])
head(vif.dt)
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif.drop = vif[-vif.top] - vif.new
vif.drop.emp = replicate(1e3, {
vif.dt[vif.top] = sample(vif.dt[vif.top])
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif.drop = vif[-vif.top] - vif.new
})
head(vif.drop.emp)
dim(vif.drop.emp)
vif.drop.null = t(vif.drop.emp)
head(vif.drop.null)
vif.drop.cut <- apply(vif.drop.null, 2, quantile(.95))
vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95))
vif.drop.cut
vif.drop
x = c(1:5)
sample(x)
x = c(1:5) * .1
sample(x)
vif.drop.null <- t(replicate(1e3, {
vif.dt[vif.top] = sample(vif.dt[vif.top])
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95))
vif.drop.cut
vif.drop.null
vif = diag(MASS::ginv(cor(vif.dt)))
vif
head(vif.dt)
vif.dt[vif.top] = sample(vif.dt[vif.top])
head(vif.dt)
head(sample(vif.dt[vif.top]))
head(vif.dt[vif.top])
head(sample(vif.dt[vif.top]))
head(sample(vif.dt[vif.top]))
head(sample(vif.dt[vif.top]))
vif.dt[vif.top] = sample(as.numeric(vif.dt[vif.top]))
vif.dt[, vif.top] = sample(vif.dt[, vif.top])
head(sample(vif.dt[, vif.top]))
head(sample(vif.dt[, vif.top]))
vif.drop.null <- t(replicate(1e3, {
vif.dt[vif.top] = sample(as.numeric(vif.dt[, vif.top]))
vif.dt[, vif.top] = sample(vif.dt[, vif.top])
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95))
vif.drop.cut
head(vif.drop.null)
hist(vif.drop.null)
head(vif.dt)
library(MASS)
library(igraph)
vif.dt = as.data.frame(matrix(rnorm(5e2, 0, 1), nrow = 1e2))
vif.dt$V2 = vif.dt$V1 + rnorm(1e2, 0, .3)
vif.dt$V3 = vif.dt$V1 + rnorm(1e2, 0, .5)
cor(vif.dt)
vif.dt$V4 = vif.dt$V1 + rnorm(1e2, 0, .7)
cor(vif.dt)
vif.dt$V2 = vif.dt$V1 + rnorm(1e2, 0, .3)
vif.dt$V3 = vif.dt$V1 + rnorm(1e2, 0, .6)
vif.dt$V4 = vif.dt$V1 + rnorm(1e2, 0, .9)
cor(vif.dt)
vif = sapply(names(vif.dt), function(x) {
toy.dt = vif.dt[c(x, setdiff(names(vif.dt), x))]
names(toy.dt) = paste0("V", 1:5)
toy.lm = summary(lm(V1 ~ V2 + V3 + V4 + V5, data = toy.dt))
1 / ( 1 - toy.lm$r.squared )
})
(vif <- sapply(names(vif.dt), function(x) {
toy.dt = vif.dt[c(x, setdiff(names(vif.dt), x))]
names(toy.dt) = paste0("V", 1:5)
toy.lm = summary(lm(V1 ~ V2 + V3 + V4 + V5, data = toy.dt))
1 / ( 1 - toy.lm$r.squared )
}))
(vif = diag(MASS::ginv(cor(vif.dt))))
names(vif) = names(vif.dt)
(vif.top = which.max(vif))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
names(vif.new) = names(vif.dt)[-vif.top]
vif.drop = vif[-vif.top] - vif.new
(vif.drop = vif[-vif.top] - vif.new)
vif.drop.null <- t(replicate(1e3, {
vif.dt[vif.top] = sample(as.numeric(vif.dt[, vif.top]))
vif.dt[, vif.top] = sample(vif.dt[, vif.top])
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
(vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95)))
vif
toshuffle = setdiff(1:ncol(vif.dt), vif.top)
toshuffle
(vif = diag(MASS::ginv(cor(vif.dt))))
names(vif) = names(vif.dt)
vif.drop.null <- t(replicate(1e3, {
toshuffle = setdiff(1:ncol(vif.dt), vif.top)
vif.dt[, toshuffle] = sapply(toshuffle, function(x) sample(vif.dt[, x]))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
(vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95)))
vif.drop
sapply(toshuffle, function(x) sample(vif.dt[, x]))
(vif.drop = vif[-vif.top] - vif.new)
(vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95)))
vif.drop.null <- t(replicate(1e3, {
vif.dt[vif.top] = sample(as.numeric(vif.dt[, vif.top]))
vif.dt[, vif.top] = sample(vif.dt[, vif.top])
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
(vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95)))
vif.dt = as.data.frame(matrix(rnorm(5e2, 0, 1), nrow = 1e2))
vif.dt$V2 = vif.dt$V1 + rnorm(1e2, 0, .3)
vif.dt$V3 = vif.dt$V1 + rnorm(1e2, 0, .6)
vif.dt$V4 = vif.dt$V1 + rnorm(1e2, 0, .9)
cor(vif.dt)
(vif <- sapply(names(vif.dt), function(x) {
toy.dt = vif.dt[c(x, setdiff(names(vif.dt), x))]
names(toy.dt) = paste0("V", 1:5)
toy.lm = summary(lm(V1 ~ V2 + V3 + V4 + V5, data = toy.dt))
1 / ( 1 - toy.lm$r.squared )
}))
(vif = diag(MASS::ginv(cor(vif.dt))))
names(vif) = names(vif.dt)
(vif.top = which.max(vif))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
names(vif.new) = names(vif.dt)[-vif.top]
(vif.drop = vif[-vif.top] - vif.new)
vif.drop.null <- t(replicate(1e3, {
vif.dt[vif.top] = sample(as.numeric(vif.dt[, vif.top]))
vif.dt[, vif.top] = sample(vif.dt[, vif.top])
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
(vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95)))
vif.drop.null <- t(replicate(1e3, {
vif.dt[, vif.top] = sample(vif.dt[, vif.top])
vif = diag(MASS::ginv(cor(vif.dt)))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
(vif.drop.cut <- apply(vif.drop.null, 2, function(x) quantile(x, .95)))
(vif.drop = vif[-vif.top] - vif.new)
vif.drop.null.leon <- t(replicate(1e3, {
toshuffle = setdiff(1:ncol(vif.dt), vif.top)
vif.dt[, toshuffle] = sapply(toshuffle, function(x) sample(vif.dt[, x]))
vif.new = diag(MASS::ginv(cor(vif.dt[-vif.top])))
vif[-vif.top] - vif.new
}))
(vif.drop.cut.leon <- apply(vif.drop.null.leon, 2, function(x) quantile(x, .95)))
vif.drop
vif.drop - vif.drop.cut.leon
vif.drop - vif.drop.cut
(vif.drop.cut.leon <- quantile(c(vif.drop.null.leon, .95))
vif.drop - vif.drop.cut.leon
dvif = compute_dvif(this.mat,top_vif)
dvif_thresh = compute_dvif_thresh(this.mat, top_vif, nshuffle, prctle)
corr_vars = variables_considered[which(dvif>dvif_thresh)]
compute_dvif <- function(mat, iremove){ #function for computing delta VIF after removing variable(s) iremove
vif1 = compute_vif(mat)
vif2 = compute_vif(mat[,-iremove])
dvif = log(vif1[-iremove]/vif2)
return(dvif)
}
shuffle_mat <- function(mat, iremove){ #shuffle columns of matrix except for variable iremove
allcolumns = 1:dim(mat)[2]
columns_for_shuffle = allcolumns[-iremove]
shuffled_selection = sapply(columns_for_shuffle, function(col) sample(as.numeric(mat[,col])))
shuffled_mat = mat
shuffled_mat[,columns_for_shuffle] = shuffled_selection
return(shuffled_mat)
}
compute_dvif_thresh <- function(mat, iremove, nshuffle, prctle){ #estimate threshold delta vif for removing iremove
#by shuffling data (mat) nshuffle times and taking the prctle percentile value of the resulting distribution of delta vifs
#actually we want nshuffle samples but each shuffle of mat gives us ncol(mat) - 1 values
#so really we only need to shuffle ceiling(nshuffle/(ncol(mat) - 1)) times
nreps = ceiling(nshuffle/(ncol(mat) - 1))
dvif_shuff = c(replicate(nreps, compute_dvif(shuffle_mat(mat,iremove),iremove)))
thresh = as.numeric(quantile(dvif_shuff,prctle))
return(thresh)
}
prune_variables_iter <- function(mat, keep, nshuffle = 1000, prctle = 0.95, cor.thresh = 0.9) { #do one variable pruning iteration inside cluster with data mat.
#input keep is vector with indicator for each variable in mat.
#2: variable is kept. 1: variable has not been dealt with yet. 0: variable has been eliminated.
#function returns keep2, which sets eliminated variables to 0 and kept variables to 2
keep2 = keep
this.mat = mat[,which(keep==1)]
this.vars = which(keep==1)
nvar = length(this.vars)
vif = compute_vif(this.mat)
top_vif = which.max(vif)
top_vif_abs = this.vars[top_vif]
variables_considered = this.vars[-top_vif]
dvif = compute_dvif(this.mat,top_vif)
dvif_thresh = compute_dvif_thresh(this.mat, top_vif, nshuffle, prctle)
corr_vars = variables_considered[which(dvif>dvif_thresh)]
#plot(variables_considered,dvif,xlim=c(1,nvar))
#abline(h=dvif_thresh)
keep2[top_vif_abs] = 2
keep2[corr_vars] = 0
return(keep2)
}
prune_cluster <- function(mat, cor.thresh = 0.9, toponly = FALSE, nshuffle = 1000, prctle = 0.95, verbose = TRUE) {
if (verbose) cat(dim(mat)[2], " variables in cluster; starting pruning.\n")
if (toponly) {
if (verbose) cat("Keeping only variable with top VIF.\n")
keep = keep_top(mat)
} else {
keep = rep(0,dim(mat)[2])
keep2 = rep(1,dim(mat)[2])
while(!identical(keep,keep2) && sum(keep2==1)>0){
keep = keep2
keep2 = prune_variables_iter(mat, keep, nshuffle, prctle, cor.thresh)
print(keep2) # for debugging
if(verbose) cat("Pruning iteratively, ", sum(keep2>0), " variables remaining in cluster.\n")
}
keep = keep2
}
if(verbose) cat("Finished pruning, ", sum(keep>0), " variables remaining in cluster.\n")
if(verbose){
vifmat = compute_vif(mat)
plot(vifmat)
points(which(keep>0), vifmat[which(keep>0)], pch=0, col='red')
}
names_to_keep = colnames(mat)[which(keep>0)]
return(names_to_keep)
}
prune_dataframe <- function(df, cor.thresh = 0.9, toponly = FALSE, nshuffle = 1000, prctle = 0.95, verbose = TRUE){
cor.table = fastCorTable(df, cor.thresh, 1, nblocks=ceiling(dim(df)[2]/1500), verbose=F)
if (dim(cor.table)[1] > 0){
#create igraph graph
g = graph_from_edgelist(as.matrix(cor.table[,-3]), directed=F)
# extract the clusters from the graph
cluster.size = components(g)$csize
cluster.membership = components(g)$membership
if(verbose) cat("Building graph with ", length(cluster.membership), " nodes and ", length(cluster.size), "components.\n")
# loop through each cluster and select representative genes
tokeep = c()
for(cluster in 1:length(cluster.size)){
cat("Pruning cluster ", cluster, " out of ", length(cluster.size), ".\n")
cluster.genes = names(which(cluster.membership==cluster))
cluster.mat = df[,colnames(df)%in%cluster.genes]
cluster.tokeep = prune_cluster(cluster.mat, cor.thresh, toponly, nshuffle, prctle, verbose)
tokeep = append(tokeep,cluster.tokeep)
}
toremove = names(cluster.membership)[!names(cluster.membership)%in%tokeep]
if (verbose) cat("Removing a total of ", length(toremove), " variables from dataframe.\n")
pruned.df = df[,!colnames(df)%in%toremove]
} else {
cat("No two variables correlated above threshold!\n")
pruned.df = df
}
return(pruned.df)
}
(vif.drop.cut.leon <- quantile(c(vif.drop.null.leon), .95))
vif.drop - vif.drop.cut.leon
vif.drop.cut.leon
c(vif.drop.null.leon)
xx = c(vif.drop.null.leon)
summary(vif.drop.null.leon[, 1])
summary(vif.drop.null.leon[, 2])
summary(vif.drop.null.leon[, 3])
summary(vif.drop.null.leon[, 4])
vif.drop - vif.drop.cut.leon
n <- 20 # Number
a <- 3 # Intercept
b <- 1 # Slope
x <- 1:20 # Pedictor
n <- 20 # Number
x <- 1:n # Pedictor
eps <- rnorm(n, mean = 0, sd = 3)
y <- a + b*x + eps # Assemble data
summary(lm(y ~ x))
eps <- rnorm(n, mean = 0, sd = 1)
y <- a + b*x + eps # Assemble data
summary(lm(y ~ x))
plot(x, y)
stanfit <- stan(file = "bpvalue.stan", data = stan.dt, iter = 1200, warmup = 200, chain = 1)
library(rstan)
setwd("~/GitHub/Genetics/rstan")
stanfit <- stan(file = "bpvalue.stan", data = stan.dt, iter = 1200, warmup = 200, chain = 1)
stan.dt <- list(n = n, x = x, y = y)
stanfit <- stan(file = "bpvalue.stan", data = stan.dt, iter = 1200, warmup = 200, chain = 1)
print(stanfit, dig = 3)
print(stanfit)
print(stanfit, dig = 3)
posterior <- extract(stanfit, inc_warmup = FALSE)
names(posterior)
dim(posterior$mu)
apply(posterior$mu, 2, mean) # mean point estimates
y
mu.mean = apply(posterior$mu, 2, mean) # mean point estimates
plot(mu.mean, y)
posterior$sigma
y.rep <- apply(posterior, MARGIN = 1:2, FUN = function(draw) {
rnorm(n, mean = draw[grepl("^mu", names(draw))], sd = draw["sigma"])
})
rnorm(n, mean = posterior$mu, sd = posterior$sigma)
posterior$mu
dim(posterior$mu)
rnorm(2, mean = c(1:2), sd = 1)
rnorm(2, mean = c(1, 20), sd = 1)
rnorm(2, mean = c(1, 20), sd = 1)
rnorm(2, mean = c(1, 20), sd = 1)
rnorm(2, mean = c(1, 20), sd = 1)
rnorm(2, mean = c(1, 20), sd = 1)
rnorm(2, mean = c(1, 20), sd = 1)
y.new = sapply(1:1000, function(iter) {
rnorm(n, mean = posterior$mu[iter, ], sd = posterior$sigma[iter, ])
})
dim(posterior$mu)
n
dim(posterior$iter)
length(posterior$iter)
length(posterior$sigma)
y.new = sapply(1:1000, function(iter) {
rnorm(n, mean = posterior$mu[iter, ], sd = posterior$sigma[iter])
})
<<<<<<< HEAD
myout = as.data.frame(myout)
head(myout)
myout
xx = myfs1[myfs1$fixedDataRow == 369, ]
load(file = "/Users/xwang/Projects/roche34/R/roche_q3_rnaseq.rdt")
load(file = "/Users/xwang/Projects/roche34/R/roche_q3_refsdf.rdt")
which(refsdf.c1$or_OR == 2)
head(xx)
yy = which(refsdf.c1$or_OR == 2)
myout[yy, ]
myout = as.data.frame(myout)
myout$P.val = pval
myout = myout[refsdf.c1$or_OR != 2, ]
dim(myout)
write.xlsx(myout, file = "/Users/xwang/Projects/roche34/report_otf.xlsx", sheetName = "Model 1 - OR", append = T)
load("/home/xwang/roche34/data/roche_q3_refsdf.rdt")
load("/Users/xwang/Projects/roche34/R/roche_q3_asl2.rdt")
table(myasl2$REG)
table(myasl2$ETHNIC)
rm(list = ls())
load("/Users/xwang/Projects/roche34/otf/edgeAll.rdt") # 0.2 cutoff
edges = edgeAll$m1
edges.ooi = edges %>% filter(grepl("^pfs_|^or_|^os_", output))
library(dplyr)
library(igraph)
library(xlsx)
edges.ooi = edges %>% filter(grepl("^pfs_|^or_|^os_", output))
edges = edgeAll$m1
head(edges)
head(edgeAll$m1())
load("/Users/xwang/Projects/roche34/otf/edgeAll.rdt") # 0.2 cutoff
edges = edgeAll$m1
edges.ooi = edges %>% filter(grepl("^pfs_|^or_|^os_", output))
write.xlsx(edges, file = "/Users/xwang/Projects/roche34/otf/report_otf.xlsx", sheetName = "Model 1", append = T)
write.xlsx(edges.ooi, file = "/Users/xwang/Projects/roche34/otf/report_otf.xlsx", sheetName = "Model 1 - outcomes", append = T)
edges = edgeAll$m2
edges.ooi = edges %>% filter(grepl("^pfs_|^or_|^os_", output))
write.xlsx(edges, file = "/Users/xwang/Projects/roche34/otf/report_otf.xlsx", sheetName = "Model 2", append = T)
write.xlsx(edges.ooi, file = "/Users/xwang/Projects/roche34/otf/report_otf.xlsx", sheetName = "Model 2 - outcomes", append = T)
edges = edgeAll$m4
edges.ooi = edges %>% filter(grepl("^pfs_|^or_|^os_", output))
write.xlsx(edges, file = "/Users/xwang/Projects/roche34/otf/report_otf.xlsx", sheetName = "Model 4", append = T)
write.xlsx(edges.ooi, file = "/Users/xwang/Projects/roche34/otf/report_otf.xlsx", sheetName = "Model 4 - outcomes", append = T)
load("~/Projects/roche34/otf/alldata.rdt")
setdiff(names(refsdf.c2), names(refsdf.c1))
setdiff(names(refsdf.c1), names(refsdf.c2))
?pnorm
library(rstan)
rm(list = ls())
setwd("~/gitHub/Genetics/rstan")
stan.lm <- stan_model("prior.stan")
stan.lm <- stan_model("./prior.stan")
file = "~/bitbucket/mydag/gaussian.stan"
mymodel = stan_model(file, model_name = "occam-1")
=======
dim(y.new)
y.new = t(sapply(1:1000, function(iter) {
rnorm(n, mean = posterior$mu[iter, ], sd = posterior$sigma[iter])
}))
head(y.new)
colMeans(y.new)
rowMeans(y.new)
mu.mc
posterior$mu
dim(posterior$mu)
y - posterior$mu
dim(y - posterior$mu)
residual <- y - posterior$mu
dim(y - posterior$mu)residuals.lm()
residual[1:5, 1:5]
y
y = posterior[1, ]
y = posterior$mu[1, ]
y <- a + b*x + eps # Assemble data
y - posterior$mu[1, ]
n <- 20 # Number
x <- 1:n # Pedictor
a <- 3 # Intercept
b <- 1 # Slope
eps <- rnorm(n, mean = 0, sd = 1)
y <- a + b*x + eps # Assemble data
plot(x, y)
summary(lm(y ~ x))
stan.dt <- list(n = n, x = x, y = y)
stanfit <- stan(file = "bpvalue.stan", data = stan.dt, iter = 1200, warmup = 200, chain = 1)
print(stanfit, dig = 3)
posterior <- extract(stanfit, inc_warmup = FALSE)
mu.mean = apply(posterior$mu, 2, mean) # mean point estimates
plot(mu.mean, y)
y.new = t(sapply(1:1000, function(iter) {
rnorm(n, mean = posterior$mu[iter, ], sd = posterior$sigma[iter])
}))
res <- y - posterior$mu
y
res[1:3, 1:5]
y - posterior$mu[1, ]
res <- y - t(posterior$mu)
res[1:3, 1:5]
y - posterior$mu[1, ]
dim(res)
x = c(1:4, nrow = 2)
x
x = matrix(1:4, nrow = 2)
x
x^2
y.new
dim(y.new)
dim(posterior$mu)
sq.res <- (y - t(posterior$mu))^2
sq.res.new <- (y.new - posterior$mu)^2
sq.res
dim(sq.res)
dim(sq.res.new)
sq.res <- t((y - t(posterior$mu))^2)
sq.res.new <- (y.new - posterior$mu)^2
dim(sq.res.new)
dim(sq.res)
fit = rowSums(sq.res)
fit.new = rowSums(sq.res.new)
as.numeric(fit.new - fit > 0)
mean(as.numeric(fit.new - fit > 0))
>>>>>>> 5eecee47e3d57630a6dbd43636f10954fd772cb9
