# probit versus logistic links

# Pr(Y=1|X) = exp(x)/(1+exp(x)) # cumulative logistic distribution 
# Pr(Y=1|X) = Pho(x) # cumulative normal distribution

# logit is more popular in health sciences since coefficients can be interpreted in terms of odds ratios
# x = ln(p/(1-p))

x = seq(-10, 10, 0.1)

cdf.logit = exp(x) / (1+exp(x))
cdf.probit = pnorm(x, mean = 0, sd = 1)

plot(x, cdf.logit, col = "blue", type = "l")
lines(x, cdf.probit, col = "red")

dens.logit = dlogis(x, location = 0, scale = 1)
dens.probit = dnorm(x, mean = 0, sd = 1)

plot(x, dens.logit, col = "blue", type = "l", xlim = c(-6, 6))
# logistic distribution is symmetric, and is pretty much a normal distribution with some standard deviation
# so it is straight forward to approximate a logistic by a normal, or the reverse
mean(dens.logit)
sd(dens.logit)

plot(x, dens.logit, col = "blue", type = "l", ylim = c(0, 0.5))
lines(x, dens.probit, col = "red")

# more comparisons on fit reasults, likelihood and parameters et al.
set.seed(1)
diff.links = do.call(rbind, lapply(1:1e3, function(i) {
  x = rnorm(1000)
  y = rbinom(n=1000, size=1, prob=pnorm(x))
  logitModel  = glm(y~x, family=binomial(link="logit"))
  probitModel = glm(y~x, family=binomial(link="probit"))
  data.frame(logit = deviance(logitModel), probit = deviance(probitModel))
}))
  
# model fit (deviance) are very similar
plot(diff.links$logit, diff.links$probit)
# model fit by the probit link is better than the logistic link in 33.4% of the times although data were generated by probit model
mean(diff.links$probit - diff.links$logit > 0)

# Compare Stan performance using ADSP data
library(rstan)
setwd("~/GitHub/Genetics/rstan/")
logit = stan_model("logit.stan") # Stan manual
probit = stan_model("probit.stan") # Stan manual

logit2 = stan_model("logit2.stan") # modified version
probit2 = stan_model("probit2.stan") # modified version 

load("~/gitHub/wgs2/Manu/R/mdata.rdt")
load("~/gitHub/wgs2/Manu/R/sampling.rdt")
load("~/gitHub/wgs2/Manu/R/genotypes.rdt")

mcmc = mcmc[order(mcmc$P), ]
mcmc = rownames(mcmc[1:100, ]) # top 100 variants

all(mcmc %in% rownames(geno))
all(mdata$ADSP.Sample.ID %in% colnames(geno))
geno = geno[mcmc, mdata$ADSP.Sample.ID]

data <- list(N = 570, K = 4, D = 2, x = mdata[c("Age", "Sex")], y = as.numeric(mdata$AD1))
data$g = geno[1, ]

logit.mle = optimizing(logit, data = data)
probit.mle = optimizing(probit, data = data)

logit2.mle = optimizing(logit2, data = data)
probit2.mle = optimizing(probit2, data = data)

tops = lapply(1:nrow(geno), function(g1) {
  data$g = geno[g1, ]
  fit.logist = optimizing(logit2, data = data, hessian = TRUE, algorithm = "LBFGS")
  fit.probit = optimizing(probit2, data = data, hessian = TRUE, algorithm = "LBFGS")
  data.frame(logist = fit.logist$value, probit = fit.probit$value)
})

tops = as.data.frame(do.call(rbind, tops))
tops = tops[apply(tops, 1, min) > -1000, ] # bad fit, can be fixed by specify initial values; or sampling
plot(tops$logist, tops$probit, xlim = c(-590, -580), ylim = c(-590, -580), 
     xlab = "Logistic", ylab = "Probit", main = "Posterior Likelihood Probability")
abline(0, 1, col = "red")

logit.mc = sampling(logit, data = dat, chain = 1, iter = 1200, warmup = 200)
probit.mc = sampling(probit, data = dat, chain = 1, iter = 1200, warmup = 200)
probit2.mc = sampling(probit2, data = dat, chain = 1, iter = 1200, warmup = 200)
